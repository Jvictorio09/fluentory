# Generated by Django 5.1.2 on 2026-01-06 13:36

import django.db.models.deletion
import uuid
from django.conf import settings
from django.db import migrations, models


def get_booking_table_name(schema_editor):
    """Get the actual booking table name from database"""
    from django.db import connection
    try:
        with connection.cursor() as cursor:
            # Check for table with case-insensitive search
            cursor.execute("""
                SELECT table_name FROM information_schema.tables 
                WHERE table_schema = 'public' 
                AND LOWER(table_name) = LOWER('myapp_booking')
                LIMIT 1;
            """)
            result = cursor.fetchone()
            if result:
                return result[0]
            return None
    except Exception:
        return None


def safe_add_seats_booked_field(apps, schema_editor):
    """Add seats_booked field only if booking table exists"""
    from django.db import connection
    
    try:
        table_name = get_booking_table_name(schema_editor)
        if not table_name:
            # Table doesn't exist - skip database operation, state-only change
            return
        
        with connection.cursor() as cursor:
            # Double-check table exists by trying to query it
            try:
                cursor.execute(f'SELECT 1 FROM {connection.ops.quote_name(table_name)} LIMIT 1')
            except Exception:
                # Table doesn't actually exist, skip
                return
            
            # Check if column already exists
            cursor.execute("""
                SELECT EXISTS (
                    SELECT 1 FROM information_schema.columns 
                    WHERE table_schema = 'public' 
                    AND table_name = %s
                    AND column_name = 'seats_booked'
                );
            """, [table_name])
            if cursor.fetchone()[0]:
                return  # Column already exists
            
            # Add the column - use quoted identifier if table name has mixed case
            quoted_table = connection.ops.quote_name(table_name)
            try:
                cursor.execute(f'ALTER TABLE {quoted_table} ADD COLUMN "seats_booked" integer DEFAULT 1 NOT NULL CHECK ("seats_booked" >= 0);')
                cursor.execute(f'ALTER TABLE {quoted_table} ALTER COLUMN "seats_booked" DROP DEFAULT;')
            except Exception as e:
                # If table doesn't exist or column already exists, just skip
                if 'does not exist' not in str(e).lower() and 'already exists' not in str(e).lower():
                    raise
    except Exception:
        # Silently fail if table doesn't exist - this is expected for new databases
        pass


def safe_add_group_booking_field(apps, schema_editor):
    """Add group_booking field only if tables exist"""
    from django.db import connection
    
    try:
        booking_table = get_booking_table_name(schema_editor)
        if not booking_table:
            return
        
        with connection.cursor() as cursor:
            # Get bookingreminder table name (case-insensitive)
            cursor.execute("""
                SELECT table_name FROM information_schema.tables 
                WHERE table_schema = 'public' 
                AND LOWER(table_name) = LOWER('myapp_bookingreminder')
                LIMIT 1;
            """)
            result = cursor.fetchone()
            if not result:
                return
            reminder_table = result[0]
            
            # Check if column already exists
            cursor.execute("""
                SELECT EXISTS (
                    SELECT 1 FROM information_schema.columns 
                    WHERE table_schema = 'public' 
                    AND table_name = %s
                    AND column_name = 'group_booking_id'
                );
            """, [reminder_table])
            if cursor.fetchone()[0]:
                return  # Column already exists
            
            # Add the column with foreign key
            quoted_reminder = connection.ops.quote_name(reminder_table)
            quoted_booking = connection.ops.quote_name(booking_table)
            
            try:
                cursor.execute(f'ALTER TABLE {quoted_reminder} ADD COLUMN "group_booking_id" bigint NULL;')
                cursor.execute(f'ALTER TABLE {quoted_reminder} ADD CONSTRAINT "myApp_bookingreminde_group_booking_id_3ee0880a_fk_myApp_boo" FOREIGN KEY ("group_booking_id") REFERENCES {quoted_booking}("id") DEFERRABLE INITIALLY DEFERRED;')
            except Exception as e:
                # If constraint already exists or table doesn't exist, skip
                if 'already exists' not in str(e).lower() and 'does not exist' not in str(e).lower():
                    raise
    except Exception:
        # Silently fail if tables don't exist
        pass


def safe_add_one_on_one_booking_field(apps, schema_editor):
    """Add one_on_one_booking field only if tables exist"""
    from django.db import connection
    
    try:
        with connection.cursor() as cursor:
            # Check if bookingreminder table exists (case-insensitive)
            cursor.execute("""
                SELECT table_name FROM information_schema.tables 
                WHERE table_schema = 'public' 
                AND LOWER(table_name) = LOWER('myapp_bookingreminder')
                LIMIT 1;
            """)
            result = cursor.fetchone()
            if not result:
                return  # Table doesn't exist
            reminder_table = result[0]
            
            # Check if oneononebooking table exists (it should since it's created earlier in the migration)
            cursor.execute("""
                SELECT table_name FROM information_schema.tables 
                WHERE table_schema = 'public' 
                AND LOWER(table_name) = LOWER('myapp_oneononebooking')
                LIMIT 1;
            """)
            ooo_result = cursor.fetchone()
            if not ooo_result:
                return  # OneOnOneBooking table doesn't exist yet
            
            # Check if column already exists
            cursor.execute("""
                SELECT EXISTS (
                    SELECT 1 FROM information_schema.columns 
                    WHERE table_schema = 'public' 
                    AND table_name = %s
                    AND column_name = 'one_on_one_booking_id'
                );
            """, [reminder_table])
            if cursor.fetchone()[0]:
                return  # Column already exists
            
            # Add the column with foreign key
            quoted_reminder = connection.ops.quote_name(reminder_table)
            quoted_ooo = connection.ops.quote_name(ooo_result[0])
            
            try:
                cursor.execute(f'ALTER TABLE {quoted_reminder} ADD COLUMN "one_on_one_booking_id" bigint NULL;')
                cursor.execute(f'ALTER TABLE {quoted_reminder} ADD CONSTRAINT "myApp_bookingreminde_one_on_one_booking_i_fcfc9457_fk_myApp_one" FOREIGN KEY ("one_on_one_booking_id") REFERENCES {quoted_ooo}("id") DEFERRABLE INITIALLY DEFERRED;')
                # Index is created automatically by Django
            except Exception as e:
                # If constraint already exists or table doesn't exist, skip
                if 'already exists' not in str(e).lower() and 'does not exist' not in str(e).lower():
                    raise
    except Exception:
        # Silently fail if tables don't exist
        pass


def safe_remove_booking_field(apps, schema_editor):
    """Remove booking field from bookingreminder only if table exists"""
    from django.db import connection
    
    try:
        with connection.cursor() as cursor:
            # Get bookingreminder table name (case-insensitive)
            cursor.execute("""
                SELECT table_name FROM information_schema.tables 
                WHERE table_schema = 'public' 
                AND LOWER(table_name) = LOWER('myapp_bookingreminder')
                LIMIT 1;
            """)
            result = cursor.fetchone()
            if not result:
                return  # Table doesn't exist
            reminder_table = result[0]
            
            # Check if column exists
            cursor.execute("""
                SELECT EXISTS (
                    SELECT 1 FROM information_schema.columns 
                    WHERE table_schema = 'public' 
                    AND table_name = %s
                    AND column_name = 'booking_id'
                );
            """, [reminder_table])
            if not cursor.fetchone()[0]:
                return  # Column doesn't exist, nothing to remove
            
            # Remove the column
            quoted_table = connection.ops.quote_name(reminder_table)
            try:
                cursor.execute(f'ALTER TABLE {quoted_table} DROP COLUMN "booking_id" CASCADE;')
            except Exception as e:
                # If column doesn't exist, skip
                if 'does not exist' not in str(e).lower():
                    raise
    except Exception:
        # Silently fail if table doesn't exist
        pass


class Migration(migrations.Migration):

    dependencies = [
        ('myApp', '0016_alter_liveclasssession_options_course_booking_type_and_more'),
        migrations.swappable_dependency(settings.AUTH_USER_MODEL),
    ]

    operations = [
        migrations.AlterModelOptions(
            name='booking',
            options={'ordering': ['-booked_at'], 'verbose_name': 'Group Session Booking', 'verbose_name_plural': 'Group Session Bookings'},
        ),
        # Use SeparateDatabaseAndState because the unique_together constraint may not exist in DB
        # We only want to update Django's migration state, not modify the database
        migrations.SeparateDatabaseAndState(
            state_operations=[
                migrations.AlterUniqueTogether(
                    name='bookingreminder',
                    unique_together=set(),
                ),
            ],
            database_operations=[
                # Skip database operation - constraint may not exist, don't try to drop it
            ],
        ),
        # Use SeparateDatabaseAndState for AddField operations to handle missing table gracefully
        migrations.SeparateDatabaseAndState(
            state_operations=[
                migrations.AddField(
                    model_name='booking',
                    name='seats_booked',
                    field=models.PositiveIntegerField(default=1, help_text='Number of seats (always 1 per booking)'),
                ),
            ],
            database_operations=[
                migrations.RunPython(safe_add_seats_booked_field, migrations.RunPython.noop),
            ],
        ),
        migrations.SeparateDatabaseAndState(
            state_operations=[
                migrations.AddField(
                    model_name='bookingreminder',
                    name='group_booking',
                    field=models.ForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.CASCADE, related_name='reminders', to='myApp.booking'),
                ),
            ],
            database_operations=[
                migrations.RunPython(safe_add_group_booking_field, migrations.RunPython.noop),
            ],
        ),
        migrations.AlterField(
            model_name='booking',
            name='user',
            field=models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='group_bookings', to=settings.AUTH_USER_MODEL),
        ),
        migrations.CreateModel(
            name='OneOnOneBooking',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('booking_id', models.UUIDField(default=uuid.uuid4, editable=False, unique=True)),
                ('status', models.CharField(choices=[('pending', 'Pending Approval'), ('confirmed', 'Confirmed'), ('declined', 'Declined by Teacher'), ('cancelled', 'Cancelled'), ('attended', 'Attended'), ('no_show', 'No Show')], default='pending', max_length=20)),
                ('booked_at', models.DateTimeField(auto_now_add=True)),
                ('confirmed_at', models.DateTimeField(blank=True, null=True)),
                ('declined_at', models.DateTimeField(blank=True, null=True)),
                ('declined_reason', models.TextField(blank=True, help_text='Reason for declining (if applicable)')),
                ('cancelled_at', models.DateTimeField(blank=True, null=True)),
                ('cancellation_reason', models.CharField(blank=True, choices=[('student', 'Cancelled by student'), ('teacher', 'Cancelled by teacher'), ('system', 'Cancelled by system'), ('conflict', 'Scheduling conflict'), ('emergency', 'Emergency')], max_length=20)),
                ('cancellation_notes', models.TextField(blank=True)),
                ('meeting_link', models.URLField(blank=True, help_text='Zoom / Google Meet / Custom meeting link for 1:1 session')),
                ('rescheduled_at', models.DateTimeField(blank=True, null=True)),
                ('attended', models.BooleanField(default=False)),
                ('attended_at', models.DateTimeField(blank=True, null=True)),
                ('student_notes', models.TextField(blank=True, help_text='Student notes or questions')),
                ('teacher_notes', models.TextField(blank=True, help_text='Teacher notes (internal)')),
                ('is_recurring', models.BooleanField(default=False)),
                ('recurring_series_id', models.UUIDField(blank=True, help_text='ID to group recurring bookings together', null=True)),
                ('recurring_cadence', models.CharField(blank=True, choices=[('weekly', 'Weekly'), ('biweekly', 'Bi-Weekly'), ('monthly', 'Monthly'), ('custom', 'Custom')], max_length=20)),
                ('next_booking_date', models.DateTimeField(blank=True, help_text='Next booking in series', null=True)),
                ('availability_slot', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='bookings', to='myApp.teacheravailability')),
                ('course', models.ForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.CASCADE, related_name='one_on_one_bookings', to='myApp.course')),
                ('original_booking', models.ForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.SET_NULL, related_name='rescheduled_bookings', to='myApp.oneononebooking')),
                ('user', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='one_on_one_bookings', to=settings.AUTH_USER_MODEL)),
            ],
            options={
                'verbose_name': '1:1 Booking',
                'verbose_name_plural': '1:1 Bookings',
                'ordering': ['-booked_at'],
                'unique_together': {('user', 'availability_slot')},
            },
        ),
        # Use SeparateDatabaseAndState for AddField to handle missing table gracefully
        migrations.SeparateDatabaseAndState(
            state_operations=[
                migrations.AddField(
                    model_name='bookingreminder',
                    name='one_on_one_booking',
                    field=models.ForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.CASCADE, related_name='reminders', to='myApp.oneononebooking'),
                ),
            ],
            database_operations=[
                migrations.RunPython(safe_add_one_on_one_booking_field, migrations.RunPython.noop),
            ],
        ),
        # Use SeparateDatabaseAndState for RemoveField to handle missing table gracefully
        migrations.SeparateDatabaseAndState(
            state_operations=[
                migrations.RemoveField(
                    model_name='bookingreminder',
                    name='booking',
                ),
            ],
            database_operations=[
                migrations.RunPython(safe_remove_booking_field, migrations.RunPython.noop),
            ],
        ),
    ]
